@xlia< system , 1.0 >:

system< and > Trickle {
@property:
	const integer BUFF_SIZE = 2;
	type FRAGMENT enum {
		UNDEF_FRAGMENT,
		FRAGMENT_0,
		FRAGMENT_1
	}
	type INFO_KIND enum {
		INIT,
		TERMIN_CM,
		TERMIN_DM1,
		TERMIN_DM2
	}
	type DATA_MESSAGE struct {
	@property:
		var integer seq;
		var FRAGMENT fragment;
		var integer offset;
	}

@composite:
	timed lifeline #model statemachine< and > Node {
	@property:
		input parameter var DATA_MESSAGE[ 2 ] my_buff;
		input parameter var FRAGMENT[ 2 ] firmware;
		input parameter var integer[ 2 ] myseq_buff;
		input parameter var boolean[ 2 ] mydp_run;
		public static const time< ureal > $time#initial = 0;
		var time< ureal > node_time = spec::Trickle.Node.$time#initial;
		public static const time< pos_real > $delta#initial;
		var time< pos_real > z = spec::Trickle.Node.$delta#initial;
		public buffer fifo[*] bufferNode;
		public volatile var clock< pos_rational > localTime = 0;
		public output port Log(INFO_KIND information, time< pos_rational > emit_time);
		public inout port ControlMsg(integer[ 2 ] seqBuff, time< pos_rational > emit_time);
		public inout port DataMsg1(DATA_MESSAGE dataMessage, time< pos_rational > emit_time);
		public inout port DataMsg2(DATA_MESSAGE dataMessage, time< pos_rational > emit_time);
		public const integer CTRL_EXPIR = 2;
		public const integer DATA_EXPIR = 2;
		public const integer MIN_SEQ = 1;
		public var boolean undef_DM1 = false;
		public var boolean undef_DM2 = false;
		var integer[ 2 ] seq_buff;
		var uinteger i;
		var boolean localPC = true;
		var integer new_seq_buff;
		var integer new_seq;
		var FRAGMENT new_fragment;
		var integer new_offset;
		var time< pos_rational > timeEmit;

	@routine:
		macro #model routine time#get --> ($0: transient parameter time< ureal > _time_){
			return Node.node_time;
		}
		macro #model routine delta#get --> ($0: transient parameter time< pos_real > _delta_){
			return Node.z;
		}
		macro #model routine time#reset{
			Node.node_time := 0;
		}
		macro #model routine clock#reset($0: transient clock< uinteger > _clock_){
			clock#reset._clock_ := 0;
		}
		macro #model routine clock#update($0: transient clock< uinteger > _clock_){
			clock#update._clock_ := (clock#update._clock_ + Node.z);
		}
		macro #model routine Guard($0: transient boolean localCondition){ |;|
			guard Guard.localCondition;
			Node.localPC := (Node.localPC && Guard.localCondition);
		}
		macro #model routine time#update{ |ยง|
			newfresh(Node.z)
			Node.node_time := (Node.node_time + Node.z);
			Node.localTime := (Node.localTime + Node.z);
			if ${ status#is enable spec::Trickle.Node.ControlProcess }
			{
				ControlProcess.cl := (ControlProcess.cl + Node.z);
			}
			if ${ status#is enable spec::Trickle.Node.DataProcess1 }
			{
				spec::Trickle.Node.DataProcess1.cl := (spec::Trickle.Node.DataProcess1.cl + Node.z);
			}
			if ${ status#is enable spec::Trickle.Node.DataProcess2 }
			{
				spec::Trickle.Node.DataProcess2.cl := (spec::Trickle.Node.DataProcess2.cl + Node.z);
			}
		}

	@composite:
		statemachine< or > ControlProcess {
		@property:
			public var uinteger e;
			public var time< pos_rational > tau;
			public var time< pos_rational > tau_l;
			public var time< pos_rational > tau_h;
			var uinteger k;
			var uinteger c;
			var uinteger i;
			var urational t;
			var boolean consistent;
			public volatile var clock< pos_rational > cl = 0;

		@routine:
			macro #model routine doubleTau{
				if ((2 * ControlProcess.tau) <= ControlProcess.tau_h)
				{
					ControlProcess.tau := (2 * ControlProcess.tau);
				}
				else
				{
					if ((2 * ControlProcess.tau) > ControlProcess.tau_h)
					{
						ControlProcess.tau := ControlProcess.tau_h;
					}
				}
			}
			macro #model routine analyse_seq{ |;|
				{ |;|
					guard (ControlProcess.e < Node.CTRL_EXPIR);
					Node.localPC := (Node.localPC && (ControlProcess.e < Node.CTRL_EXPIR));
				}
				input Node.ControlMsg(Node.seq_buff, Node.timeEmit);
				{ |;|
					guard (Node.timeEmit <= Node.localTime);
					Node.localPC := (Node.localPC && (Node.timeEmit <= Node.localTime));
				}
				ControlProcess.consistent := true;
				for( ControlProcess.i := 0 ; (ControlProcess.i < spec::Trickle.BUFF_SIZE) ; ControlProcess.i := (+ 1) )
				{
					if (&spec::Trickle.Node.myseq_buff[&spec::Trickle.Node.ControlProcess.i] != &spec::Trickle.Node.seq_buff[&spec::Trickle.Node.ControlProcess.i])
					{ |;|
						ControlProcess.consistent := false;
						if (! &spec::Trickle.Node.mydp_run[&spec::Trickle.Node.ControlProcess.i])
						{
							&spec::Trickle.Node.mydp_run[&spec::Trickle.Node.ControlProcess.i] := true;
						}
					}
				}
			}
			macro #model routine analyse_cp1_consistent{ |;|
				{ |;|
					guard (ControlProcess.cl < ControlProcess.t);
					Node.localPC := (Node.localPC && (ControlProcess.cl < ControlProcess.t));
				}
				{ |;|
					{ |;|
						guard (ControlProcess.e < Node.CTRL_EXPIR);
						Node.localPC := (Node.localPC && (ControlProcess.e < Node.CTRL_EXPIR));
					}
					input Node.ControlMsg(Node.seq_buff, Node.timeEmit);
					{ |;|
						guard (Node.timeEmit <= Node.localTime);
						Node.localPC := (Node.localPC && (Node.timeEmit <= Node.localTime));
					}
					ControlProcess.consistent := true;
					for( ControlProcess.i := 0 ; (ControlProcess.i < spec::Trickle.BUFF_SIZE) ; ControlProcess.i := (+ 1) )
					{
						if (&spec::Trickle.Node.myseq_buff[&spec::Trickle.Node.ControlProcess.i] != &spec::Trickle.Node.seq_buff[&spec::Trickle.Node.ControlProcess.i])
						{ |;|
							ControlProcess.consistent := false;
							if (! &spec::Trickle.Node.mydp_run[&spec::Trickle.Node.ControlProcess.i])
							{
								&spec::Trickle.Node.mydp_run[&spec::Trickle.Node.ControlProcess.i] := true;
							}
						}
					}
				}
				guard ControlProcess.consistent;
				ControlProcess.c := (+ 1);
			}
			macro #model routine analyse_cp1_inconsistent{ |;|
				{ |;|
					guard (ControlProcess.cl < ControlProcess.t);
					Node.localPC := (Node.localPC && (ControlProcess.cl < ControlProcess.t));
				}
				{ |;|
					{ |;|
						guard (ControlProcess.e < Node.CTRL_EXPIR);
						Node.localPC := (Node.localPC && (ControlProcess.e < Node.CTRL_EXPIR));
					}
					input Node.ControlMsg(Node.seq_buff, Node.timeEmit);
					{ |;|
						guard (Node.timeEmit <= Node.localTime);
						Node.localPC := (Node.localPC && (Node.timeEmit <= Node.localTime));
					}
					ControlProcess.consistent := true;
					for( ControlProcess.i := 0 ; (ControlProcess.i < spec::Trickle.BUFF_SIZE) ; ControlProcess.i := (+ 1) )
					{
						if (&spec::Trickle.Node.myseq_buff[&spec::Trickle.Node.ControlProcess.i] != &spec::Trickle.Node.seq_buff[&spec::Trickle.Node.ControlProcess.i])
						{ |;|
							ControlProcess.consistent := false;
							if (! &spec::Trickle.Node.mydp_run[&spec::Trickle.Node.ControlProcess.i])
							{
								&spec::Trickle.Node.mydp_run[&spec::Trickle.Node.ControlProcess.i] := true;
							}
						}
					}
				}
				guard (! ControlProcess.consistent);
				ControlProcess.tau := ControlProcess.tau_l;
				invoke#method ControlProcess.t newfresh;
				{ |;|
					guard (((ControlProcess.tau / 2) <= ControlProcess.t) && (ControlProcess.t < ControlProcess.tau));
					Node.localPC := (Node.localPC && (((ControlProcess.tau / 2) <= ControlProcess.t) && (ControlProcess.t < ControlProcess.tau)));
				}
				ControlProcess.cl := 0;
				ControlProcess.c := 0;
				ControlProcess.e := 0;
			}
			macro #model routine analyse_cp2_consistent{ |;|
				{ |;|
					guard (ControlProcess.cl < ControlProcess.tau);
					Node.localPC := (Node.localPC && (ControlProcess.cl < ControlProcess.tau));
				}
				{ |;|
					{ |;|
						guard (ControlProcess.e < Node.CTRL_EXPIR);
						Node.localPC := (Node.localPC && (ControlProcess.e < Node.CTRL_EXPIR));
					}
					input Node.ControlMsg(Node.seq_buff, Node.timeEmit);
					{ |;|
						guard (Node.timeEmit <= Node.localTime);
						Node.localPC := (Node.localPC && (Node.timeEmit <= Node.localTime));
					}
					ControlProcess.consistent := true;
					for( ControlProcess.i := 0 ; (ControlProcess.i < spec::Trickle.BUFF_SIZE) ; ControlProcess.i := (+ 1) )
					{
						if (&spec::Trickle.Node.myseq_buff[&spec::Trickle.Node.ControlProcess.i] != &spec::Trickle.Node.seq_buff[&spec::Trickle.Node.ControlProcess.i])
						{ |;|
							ControlProcess.consistent := false;
							if (! &spec::Trickle.Node.mydp_run[&spec::Trickle.Node.ControlProcess.i])
							{
								&spec::Trickle.Node.mydp_run[&spec::Trickle.Node.ControlProcess.i] := true;
							}
						}
					}
				}
				guard ControlProcess.consistent;
				ControlProcess.c := (+ 1);
			}
			macro #model routine analyse_cp2_inconsistent{ |;|
				{ |;|
					guard (ControlProcess.cl < ControlProcess.tau);
					Node.localPC := (Node.localPC && (ControlProcess.cl < ControlProcess.tau));
				}
				{ |;|
					{ |;|
						guard (ControlProcess.e < Node.CTRL_EXPIR);
						Node.localPC := (Node.localPC && (ControlProcess.e < Node.CTRL_EXPIR));
					}
					input Node.ControlMsg(Node.seq_buff, Node.timeEmit);
					{ |;|
						guard (Node.timeEmit <= Node.localTime);
						Node.localPC := (Node.localPC && (Node.timeEmit <= Node.localTime));
					}
					ControlProcess.consistent := true;
					for( ControlProcess.i := 0 ; (ControlProcess.i < spec::Trickle.BUFF_SIZE) ; ControlProcess.i := (+ 1) )
					{
						if (&spec::Trickle.Node.myseq_buff[&spec::Trickle.Node.ControlProcess.i] != &spec::Trickle.Node.seq_buff[&spec::Trickle.Node.ControlProcess.i])
						{ |;|
							ControlProcess.consistent := false;
							if (! &spec::Trickle.Node.mydp_run[&spec::Trickle.Node.ControlProcess.i])
							{
								&spec::Trickle.Node.mydp_run[&spec::Trickle.Node.ControlProcess.i] := true;
							}
						}
					}
				}
				guard (! ControlProcess.consistent);
				ControlProcess.tau := ControlProcess.tau_l;
				invoke#method ControlProcess.t newfresh;
				{ |;|
					guard (((ControlProcess.tau / 2) <= ControlProcess.t) && (ControlProcess.t < ControlProcess.tau));
					Node.localPC := (Node.localPC && (((ControlProcess.tau / 2) <= ControlProcess.t) && (ControlProcess.t < ControlProcess.tau)));
				}
				ControlProcess.cl := 0;
				ControlProcess.c := 0;
				ControlProcess.e := 0;
			}

		@region:
			state< initial > cp0_init {
				transition cp_init --> cp0 { |;|
					ControlProcess.k := 2;
					ControlProcess.tau_l := 4;
					ControlProcess.tau_h := 8;
				}
			}

			state cp0 {
				transition cp_init --> cp1 { |;|
					ControlProcess.tau := ControlProcess.tau_l;
					invoke#method ControlProcess.t newfresh;
					{ |;|
						guard (((ControlProcess.tau / 2) <= ControlProcess.t) && (ControlProcess.t < ControlProcess.tau));
						Node.localPC := (Node.localPC && (((ControlProcess.tau / 2) <= ControlProcess.t) && (ControlProcess.t < ControlProcess.tau)));
					}
					ControlProcess.cl := 0;
					ControlProcess.c := 0;
					ControlProcess.e := 0;
					output Node.Log(INIT, Node.localTime);
				}
			}

			state cp1 {
				transition cp_sendCM --> cp2 { |;|
					{ |;|
						guard (ControlProcess.cl == ControlProcess.t);
						Node.localPC := (Node.localPC && (ControlProcess.cl == ControlProcess.t));
					}
					{ |;|
						guard ((ControlProcess.c < ControlProcess.k) && (ControlProcess.e < Node.CTRL_EXPIR));
						Node.localPC := (Node.localPC && ((ControlProcess.c < ControlProcess.k) && (ControlProcess.e < Node.CTRL_EXPIR)));
					}
					output Node.ControlMsg(Node.myseq_buff, Node.localTime);
				}
				transition cp1_receiveCM_consistent --> cp1 { |;|
					{ |;|
						guard (ControlProcess.cl < ControlProcess.t);
						Node.localPC := (Node.localPC && (ControlProcess.cl < ControlProcess.t));
					}
					{ |;|
						{ |;|
							guard (ControlProcess.e < Node.CTRL_EXPIR);
							Node.localPC := (Node.localPC && (ControlProcess.e < Node.CTRL_EXPIR));
						}
						input Node.ControlMsg(Node.seq_buff, Node.timeEmit);
						{ |;|
							guard (Node.timeEmit <= Node.localTime);
							Node.localPC := (Node.localPC && (Node.timeEmit <= Node.localTime));
						}
						ControlProcess.consistent := true;
						for( ControlProcess.i := 0 ; (ControlProcess.i < spec::Trickle.BUFF_SIZE) ; ControlProcess.i := (+ 1) )
						{
							if (&spec::Trickle.Node.myseq_buff[&spec::Trickle.Node.ControlProcess.i] != &spec::Trickle.Node.seq_buff[&spec::Trickle.Node.ControlProcess.i])
							{ |;|
								ControlProcess.consistent := false;
								if (! &spec::Trickle.Node.mydp_run[&spec::Trickle.Node.ControlProcess.i])
								{
									&spec::Trickle.Node.mydp_run[&spec::Trickle.Node.ControlProcess.i] := true;
								}
							}
						}
					}
					guard ControlProcess.consistent;
					ControlProcess.c := (+ 1);
				}
				transition cp1_receiveCM_inconsistent --> cp1 { |;|
					{ |;|
						guard (ControlProcess.cl < ControlProcess.t);
						Node.localPC := (Node.localPC && (ControlProcess.cl < ControlProcess.t));
					}
					{ |;|
						{ |;|
							guard (ControlProcess.e < Node.CTRL_EXPIR);
							Node.localPC := (Node.localPC && (ControlProcess.e < Node.CTRL_EXPIR));
						}
						input Node.ControlMsg(Node.seq_buff, Node.timeEmit);
						{ |;|
							guard (Node.timeEmit <= Node.localTime);
							Node.localPC := (Node.localPC && (Node.timeEmit <= Node.localTime));
						}
						ControlProcess.consistent := true;
						for( ControlProcess.i := 0 ; (ControlProcess.i < spec::Trickle.BUFF_SIZE) ; ControlProcess.i := (+ 1) )
						{
							if (&spec::Trickle.Node.myseq_buff[&spec::Trickle.Node.ControlProcess.i] != &spec::Trickle.Node.seq_buff[&spec::Trickle.Node.ControlProcess.i])
							{ |;|
								ControlProcess.consistent := false;
								if (! &spec::Trickle.Node.mydp_run[&spec::Trickle.Node.ControlProcess.i])
								{
									&spec::Trickle.Node.mydp_run[&spec::Trickle.Node.ControlProcess.i] := true;
								}
							}
						}
					}
					guard (! ControlProcess.consistent);
					ControlProcess.tau := ControlProcess.tau_l;
					invoke#method ControlProcess.t newfresh;
					{ |;|
						guard (((ControlProcess.tau / 2) <= ControlProcess.t) && (ControlProcess.t < ControlProcess.tau));
						Node.localPC := (Node.localPC && (((ControlProcess.tau / 2) <= ControlProcess.t) && (ControlProcess.t < ControlProcess.tau)));
					}
					ControlProcess.cl := 0;
					ControlProcess.c := 0;
					ControlProcess.e := 0;
				}
				transition cp_CTRL_EXPIR --> cp3 { |;|
					{ |;|
						guard (ControlProcess.e == Node.CTRL_EXPIR);
						Node.localPC := (Node.localPC && (ControlProcess.e == Node.CTRL_EXPIR));
					}
					output Node.Log(TERMIN_CM, Node.localTime);
				}
				transition cp1_reach_k --> cp2 { |;|
					{ |;|
						guard (ControlProcess.cl == ControlProcess.t);
						Node.localPC := (Node.localPC && (ControlProcess.cl == ControlProcess.t));
					}
					{ |;|
						guard ((ControlProcess.c >= ControlProcess.k) && (ControlProcess.e < Node.CTRL_EXPIR));
						Node.localPC := (Node.localPC && ((ControlProcess.c >= ControlProcess.k) && (ControlProcess.e < Node.CTRL_EXPIR)));
					}
				}
			}

			state cp2 {
				transition cp_resetTau --> cp1 { |;|
					{ |;|
						guard ((ControlProcess.cl > ControlProcess.t) && (ControlProcess.cl == ControlProcess.tau));
						Node.localPC := (Node.localPC && ((ControlProcess.cl > ControlProcess.t) && (ControlProcess.cl == ControlProcess.tau)));
					}
					{ |;|
						guard (ControlProcess.e < Node.CTRL_EXPIR);
						Node.localPC := (Node.localPC && (ControlProcess.e < Node.CTRL_EXPIR));
					}
					if ((2 * ControlProcess.tau) <= ControlProcess.tau_h)
					{
						ControlProcess.tau := (2 * ControlProcess.tau);
					}
					else
					{
						if ((2 * ControlProcess.tau) > ControlProcess.tau_h)
						{
							ControlProcess.tau := ControlProcess.tau_h;
						}
					}
					invoke#method ControlProcess.t newfresh;
					{ |;|
						guard (((ControlProcess.tau / 2) <= ControlProcess.t) && (ControlProcess.t < ControlProcess.tau));
						Node.localPC := (Node.localPC && (((ControlProcess.tau / 2) <= ControlProcess.t) && (ControlProcess.t < ControlProcess.tau)));
					}
					ControlProcess.e := (+ 1);
					ControlProcess.cl := 0;
					ControlProcess.c := 0;
				}
				transition cp2_receiveCM_consistent --> cp2 { |;|
					{ |;|
						guard (ControlProcess.cl < ControlProcess.tau);
						Node.localPC := (Node.localPC && (ControlProcess.cl < ControlProcess.tau));
					}
					{ |;|
						{ |;|
							guard (ControlProcess.e < Node.CTRL_EXPIR);
							Node.localPC := (Node.localPC && (ControlProcess.e < Node.CTRL_EXPIR));
						}
						input Node.ControlMsg(Node.seq_buff, Node.timeEmit);
						{ |;|
							guard (Node.timeEmit <= Node.localTime);
							Node.localPC := (Node.localPC && (Node.timeEmit <= Node.localTime));
						}
						ControlProcess.consistent := true;
						for( ControlProcess.i := 0 ; (ControlProcess.i < spec::Trickle.BUFF_SIZE) ; ControlProcess.i := (+ 1) )
						{
							if (&spec::Trickle.Node.myseq_buff[&spec::Trickle.Node.ControlProcess.i] != &spec::Trickle.Node.seq_buff[&spec::Trickle.Node.ControlProcess.i])
							{ |;|
								ControlProcess.consistent := false;
								if (! &spec::Trickle.Node.mydp_run[&spec::Trickle.Node.ControlProcess.i])
								{
									&spec::Trickle.Node.mydp_run[&spec::Trickle.Node.ControlProcess.i] := true;
								}
							}
						}
					}
					guard ControlProcess.consistent;
					ControlProcess.c := (+ 1);
				}
				transition cp2_receiveCM_inconsistent --> cp1 { |;|
					{ |;|
						guard (ControlProcess.cl < ControlProcess.tau);
						Node.localPC := (Node.localPC && (ControlProcess.cl < ControlProcess.tau));
					}
					{ |;|
						{ |;|
							guard (ControlProcess.e < Node.CTRL_EXPIR);
							Node.localPC := (Node.localPC && (ControlProcess.e < Node.CTRL_EXPIR));
						}
						input Node.ControlMsg(Node.seq_buff, Node.timeEmit);
						{ |;|
							guard (Node.timeEmit <= Node.localTime);
							Node.localPC := (Node.localPC && (Node.timeEmit <= Node.localTime));
						}
						ControlProcess.consistent := true;
						for( ControlProcess.i := 0 ; (ControlProcess.i < spec::Trickle.BUFF_SIZE) ; ControlProcess.i := (+ 1) )
						{
							if (&spec::Trickle.Node.myseq_buff[&spec::Trickle.Node.ControlProcess.i] != &spec::Trickle.Node.seq_buff[&spec::Trickle.Node.ControlProcess.i])
							{ |;|
								ControlProcess.consistent := false;
								if (! &spec::Trickle.Node.mydp_run[&spec::Trickle.Node.ControlProcess.i])
								{
									&spec::Trickle.Node.mydp_run[&spec::Trickle.Node.ControlProcess.i] := true;
								}
							}
						}
					}
					guard (! ControlProcess.consistent);
					ControlProcess.tau := ControlProcess.tau_l;
					invoke#method ControlProcess.t newfresh;
					{ |;|
						guard (((ControlProcess.tau / 2) <= ControlProcess.t) && (ControlProcess.t < ControlProcess.tau));
						Node.localPC := (Node.localPC && (((ControlProcess.tau / 2) <= ControlProcess.t) && (ControlProcess.t < ControlProcess.tau)));
					}
					ControlProcess.cl := 0;
					ControlProcess.c := 0;
					ControlProcess.e := 0;
				}
			}

			state< final > cp3 {
			}

		@moe:
		}

		#model statemachine< or > DataProcess {
		@property:
			input parameter var integer mySeq;
			public var uinteger e;
			public var time< pos_rational > tau;
			public var time< pos_rational > tau_l;
			public var time< pos_rational > tau_h;
			var uinteger k;
			var uinteger c;
			var uinteger i;
			var urational t;
			var boolean consistent;
			public volatile var clock< pos_rational > cl = 0;
			var DATA_MESSAGE d;

		@routine:
			macro #model routine doubleTau{
				if ((2 * DataProcess.tau) <= DataProcess.tau_h)
				{
					DataProcess.tau := (2 * DataProcess.tau);
				}
				else
				{
					if ((2 * DataProcess.tau) > DataProcess.tau_h)
					{
						DataProcess.tau := DataProcess.tau_h;
					}
				}
			}
			macro #model routine inputDataMsg{
				if (DataProcess.mySeq == 1)
				{
					input Node.DataMsg1(DataProcess.d, Node.timeEmit);
				}
				else
				{
					input Node.DataMsg2(DataProcess.d, Node.timeEmit);
				}
			}
			macro #model routine outputDataMsg{
				if (DataProcess.mySeq == 1)
				{
					output Node.DataMsg1(&spec::Trickle.Node.my_buff[(DataProcess.mySeq + (- Node.MIN_SEQ))], Node.localTime);
				}
				else
				{
					if (DataProcess.mySeq == 2)
					{
						output Node.DataMsg2(&spec::Trickle.Node.my_buff[(DataProcess.mySeq + (- Node.MIN_SEQ))], Node.localTime);
					}
				}
			}
			macro #model routine outputLog{
				if (DataProcess.mySeq == 1)
				{
					output Node.Log(TERMIN_DM1, Node.localTime);
				}
				else
				{
					if (DataProcess.mySeq == 2)
					{
						output Node.Log(TERMIN_DM2, Node.localTime);
					}
				}
			}
			macro #model routine analyse_data{ |;|
				{ |;|
					guard (DataProcess.e < Node.DATA_EXPIR);
					Node.localPC := (Node.localPC && (DataProcess.e < Node.DATA_EXPIR));
				}
				if (DataProcess.mySeq == 1)
				{
					input Node.DataMsg1(DataProcess.d, Node.timeEmit);
				}
				else
				{
					input Node.DataMsg2(DataProcess.d, Node.timeEmit);
				}
				{ |;|
					guard (Node.timeEmit <= Node.localTime);
					Node.localPC := (Node.localPC && (Node.timeEmit <= Node.localTime));
				}
				DataProcess.consistent := true;
				if (DataProcess.mySeq == &spec::Trickle.Node.DataProcess.d.seq)
				{ |;|
					&spec::Trickle.Node.my_buff[(&spec::Trickle.Node.DataProcess.d.seq + (- Node.MIN_SEQ))] := DataProcess.d;
					&spec::Trickle.Node.myseq_buff[(&spec::Trickle.Node.DataProcess.d.seq + (- Node.MIN_SEQ))] := 1;
					&spec::Trickle.Node.firmware[&spec::Trickle.Node.DataProcess.d.offset] := &spec::Trickle.Node.DataProcess.d.fragment;
				}
				else
				{
					DataProcess.consistent := false;
				}
			}
			macro #model routine analyse_dp1_consistent{ |;|
				{ |;|
					guard (DataProcess.cl < DataProcess.t);
					Node.localPC := (Node.localPC && (DataProcess.cl < DataProcess.t));
				}
				{ |;|
					{ |;|
						guard (DataProcess.e < Node.DATA_EXPIR);
						Node.localPC := (Node.localPC && (DataProcess.e < Node.DATA_EXPIR));
					}
					if (DataProcess.mySeq == 1)
					{
						input Node.DataMsg1(DataProcess.d, Node.timeEmit);
					}
					else
					{
						input Node.DataMsg2(DataProcess.d, Node.timeEmit);
					}
					{ |;|
						guard (Node.timeEmit <= Node.localTime);
						Node.localPC := (Node.localPC && (Node.timeEmit <= Node.localTime));
					}
					DataProcess.consistent := true;
					if (DataProcess.mySeq == &spec::Trickle.Node.DataProcess.d.seq)
					{ |;|
						&spec::Trickle.Node.my_buff[(&spec::Trickle.Node.DataProcess.d.seq + (- Node.MIN_SEQ))] := DataProcess.d;
						&spec::Trickle.Node.myseq_buff[(&spec::Trickle.Node.DataProcess.d.seq + (- Node.MIN_SEQ))] := 1;
						&spec::Trickle.Node.firmware[&spec::Trickle.Node.DataProcess.d.offset] := &spec::Trickle.Node.DataProcess.d.fragment;
					}
					else
					{
						DataProcess.consistent := false;
					}
				}
				guard DataProcess.consistent;
				DataProcess.c := (+ 1);
			}
			macro #model routine analyse_dp1_inconsistent{ |;|
				{ |;|
					guard (DataProcess.cl < DataProcess.t);
					Node.localPC := (Node.localPC && (DataProcess.cl < DataProcess.t));
				}
				{ |;|
					{ |;|
						guard (DataProcess.e < Node.DATA_EXPIR);
						Node.localPC := (Node.localPC && (DataProcess.e < Node.DATA_EXPIR));
					}
					if (DataProcess.mySeq == 1)
					{
						input Node.DataMsg1(DataProcess.d, Node.timeEmit);
					}
					else
					{
						input Node.DataMsg2(DataProcess.d, Node.timeEmit);
					}
					{ |;|
						guard (Node.timeEmit <= Node.localTime);
						Node.localPC := (Node.localPC && (Node.timeEmit <= Node.localTime));
					}
					DataProcess.consistent := true;
					if (DataProcess.mySeq == &spec::Trickle.Node.DataProcess.d.seq)
					{ |;|
						&spec::Trickle.Node.my_buff[(&spec::Trickle.Node.DataProcess.d.seq + (- Node.MIN_SEQ))] := DataProcess.d;
						&spec::Trickle.Node.myseq_buff[(&spec::Trickle.Node.DataProcess.d.seq + (- Node.MIN_SEQ))] := 1;
						&spec::Trickle.Node.firmware[&spec::Trickle.Node.DataProcess.d.offset] := &spec::Trickle.Node.DataProcess.d.fragment;
					}
					else
					{
						DataProcess.consistent := false;
					}
				}
				guard (! DataProcess.consistent);
				DataProcess.tau := DataProcess.tau_l;
				invoke#method DataProcess.t newfresh;
				{ |;|
					guard (((DataProcess.tau / 2) <= DataProcess.t) && (DataProcess.t < DataProcess.tau));
					Node.localPC := (Node.localPC && (((DataProcess.tau / 2) <= DataProcess.t) && (DataProcess.t < DataProcess.tau)));
				}
				DataProcess.cl := 0;
				DataProcess.c := 0;
				DataProcess.e := 0;
			}
			macro #model routine analyse_dp2_consistent{ |;|
				{ |;|
					guard (DataProcess.cl < DataProcess.tau);
					Node.localPC := (Node.localPC && (DataProcess.cl < DataProcess.tau));
				}
				{ |;|
					{ |;|
						guard (DataProcess.e < Node.DATA_EXPIR);
						Node.localPC := (Node.localPC && (DataProcess.e < Node.DATA_EXPIR));
					}
					if (DataProcess.mySeq == 1)
					{
						input Node.DataMsg1(DataProcess.d, Node.timeEmit);
					}
					else
					{
						input Node.DataMsg2(DataProcess.d, Node.timeEmit);
					}
					{ |;|
						guard (Node.timeEmit <= Node.localTime);
						Node.localPC := (Node.localPC && (Node.timeEmit <= Node.localTime));
					}
					DataProcess.consistent := true;
					if (DataProcess.mySeq == &spec::Trickle.Node.DataProcess.d.seq)
					{ |;|
						&spec::Trickle.Node.my_buff[(&spec::Trickle.Node.DataProcess.d.seq + (- Node.MIN_SEQ))] := DataProcess.d;
						&spec::Trickle.Node.myseq_buff[(&spec::Trickle.Node.DataProcess.d.seq + (- Node.MIN_SEQ))] := 1;
						&spec::Trickle.Node.firmware[&spec::Trickle.Node.DataProcess.d.offset] := &spec::Trickle.Node.DataProcess.d.fragment;
					}
					else
					{
						DataProcess.consistent := false;
					}
				}
				guard DataProcess.consistent;
				DataProcess.c := (+ 1);
			}
			macro #model routine analyse_dp2_inconsistent{ |;|
				{ |;|
					guard (DataProcess.cl < DataProcess.tau);
					Node.localPC := (Node.localPC && (DataProcess.cl < DataProcess.tau));
				}
				{ |;|
					{ |;|
						guard (DataProcess.e < Node.DATA_EXPIR);
						Node.localPC := (Node.localPC && (DataProcess.e < Node.DATA_EXPIR));
					}
					if (DataProcess.mySeq == 1)
					{
						input Node.DataMsg1(DataProcess.d, Node.timeEmit);
					}
					else
					{
						input Node.DataMsg2(DataProcess.d, Node.timeEmit);
					}
					{ |;|
						guard (Node.timeEmit <= Node.localTime);
						Node.localPC := (Node.localPC && (Node.timeEmit <= Node.localTime));
					}
					DataProcess.consistent := true;
					if (DataProcess.mySeq == &spec::Trickle.Node.DataProcess.d.seq)
					{ |;|
						&spec::Trickle.Node.my_buff[(&spec::Trickle.Node.DataProcess.d.seq + (- Node.MIN_SEQ))] := DataProcess.d;
						&spec::Trickle.Node.myseq_buff[(&spec::Trickle.Node.DataProcess.d.seq + (- Node.MIN_SEQ))] := 1;
						&spec::Trickle.Node.firmware[&spec::Trickle.Node.DataProcess.d.offset] := &spec::Trickle.Node.DataProcess.d.fragment;
					}
					else
					{
						DataProcess.consistent := false;
					}
				}
				guard (! DataProcess.consistent);
				DataProcess.tau := DataProcess.tau_l;
				invoke#method DataProcess.t newfresh;
				{ |;|
					guard (((DataProcess.tau / 2) <= DataProcess.t) && (DataProcess.t < DataProcess.tau));
					Node.localPC := (Node.localPC && (((DataProcess.tau / 2) <= DataProcess.t) && (DataProcess.t < DataProcess.tau)));
				}
				DataProcess.cl := 0;
				DataProcess.c := 0;
				DataProcess.e := 0;
			}

		@region:
			state< start > dp0 {
				transition dp_init --> dp1 { |;|
					DataProcess.k := 2;
					DataProcess.tau_l := 4;
					DataProcess.tau_h := 8;
					guard &spec::Trickle.Node.mydp_run[(DataProcess.mySeq + (- Node.MIN_SEQ))];
					DataProcess.tau := DataProcess.tau_l;
					invoke#method DataProcess.t newfresh;
					{ |;|
						guard (((DataProcess.tau / 2) <= DataProcess.t) && (DataProcess.t < DataProcess.tau));
						Node.localPC := (Node.localPC && (((DataProcess.tau / 2) <= DataProcess.t) && (DataProcess.t < DataProcess.tau)));
					}
					DataProcess.cl := 0;
					DataProcess.c := 0;
					DataProcess.e := 0;
				}
			}

			state dp1 {
				transition dp_sendDM --> dp2 { |;|
					{ |;|
						guard (DataProcess.cl == DataProcess.t);
						Node.localPC := (Node.localPC && (DataProcess.cl == DataProcess.t));
					}
					{ |;|
						guard ((DataProcess.c < DataProcess.k) && (DataProcess.e < Node.DATA_EXPIR) && (&spec::Trickle.Node.my_buff[(DataProcess.mySeq + (- Node.MIN_SEQ))].fragment != UNDEF_FRAGMENT));
						Node.localPC := (Node.localPC && ((DataProcess.c < DataProcess.k) && (DataProcess.e < Node.DATA_EXPIR) && (&spec::Trickle.Node.my_buff[(DataProcess.mySeq + (- Node.MIN_SEQ))].fragment != UNDEF_FRAGMENT)));
					}
					if (DataProcess.mySeq == 1)
					{
						output Node.DataMsg1(&spec::Trickle.Node.my_buff[(DataProcess.mySeq + (- Node.MIN_SEQ))], Node.localTime);
					}
					else
					{
						if (DataProcess.mySeq == 2)
						{
							output Node.DataMsg2(&spec::Trickle.Node.my_buff[(DataProcess.mySeq + (- Node.MIN_SEQ))], Node.localTime);
						}
					}
				}
				transition dp1_receiveDM_consistent --> dp1 { |;|
					{ |;|
						guard (DataProcess.cl < DataProcess.t);
						Node.localPC := (Node.localPC && (DataProcess.cl < DataProcess.t));
					}
					{ |;|
						{ |;|
							guard (DataProcess.e < Node.DATA_EXPIR);
							Node.localPC := (Node.localPC && (DataProcess.e < Node.DATA_EXPIR));
						}
						if (DataProcess.mySeq == 1)
						{
							input Node.DataMsg1(DataProcess.d, Node.timeEmit);
						}
						else
						{
							input Node.DataMsg2(DataProcess.d, Node.timeEmit);
						}
						{ |;|
							guard (Node.timeEmit <= Node.localTime);
							Node.localPC := (Node.localPC && (Node.timeEmit <= Node.localTime));
						}
						DataProcess.consistent := true;
						if (DataProcess.mySeq == &spec::Trickle.Node.DataProcess.d.seq)
						{ |;|
							&spec::Trickle.Node.my_buff[(&spec::Trickle.Node.DataProcess.d.seq + (- Node.MIN_SEQ))] := DataProcess.d;
							&spec::Trickle.Node.myseq_buff[(&spec::Trickle.Node.DataProcess.d.seq + (- Node.MIN_SEQ))] := 1;
							&spec::Trickle.Node.firmware[&spec::Trickle.Node.DataProcess.d.offset] := &spec::Trickle.Node.DataProcess.d.fragment;
						}
						else
						{
							DataProcess.consistent := false;
						}
					}
					guard DataProcess.consistent;
					DataProcess.c := (+ 1);
				}
				transition dp1_receiveDM_inconsistent --> dp1 { |;|
					{ |;|
						guard (DataProcess.cl < DataProcess.t);
						Node.localPC := (Node.localPC && (DataProcess.cl < DataProcess.t));
					}
					{ |;|
						{ |;|
							guard (DataProcess.e < Node.DATA_EXPIR);
							Node.localPC := (Node.localPC && (DataProcess.e < Node.DATA_EXPIR));
						}
						if (DataProcess.mySeq == 1)
						{
							input Node.DataMsg1(DataProcess.d, Node.timeEmit);
						}
						else
						{
							input Node.DataMsg2(DataProcess.d, Node.timeEmit);
						}
						{ |;|
							guard (Node.timeEmit <= Node.localTime);
							Node.localPC := (Node.localPC && (Node.timeEmit <= Node.localTime));
						}
						DataProcess.consistent := true;
						if (DataProcess.mySeq == &spec::Trickle.Node.DataProcess.d.seq)
						{ |;|
							&spec::Trickle.Node.my_buff[(&spec::Trickle.Node.DataProcess.d.seq + (- Node.MIN_SEQ))] := DataProcess.d;
							&spec::Trickle.Node.myseq_buff[(&spec::Trickle.Node.DataProcess.d.seq + (- Node.MIN_SEQ))] := 1;
							&spec::Trickle.Node.firmware[&spec::Trickle.Node.DataProcess.d.offset] := &spec::Trickle.Node.DataProcess.d.fragment;
						}
						else
						{
							DataProcess.consistent := false;
						}
					}
					guard (! DataProcess.consistent);
					DataProcess.tau := DataProcess.tau_l;
					invoke#method DataProcess.t newfresh;
					{ |;|
						guard (((DataProcess.tau / 2) <= DataProcess.t) && (DataProcess.t < DataProcess.tau));
						Node.localPC := (Node.localPC && (((DataProcess.tau / 2) <= DataProcess.t) && (DataProcess.t < DataProcess.tau)));
					}
					DataProcess.cl := 0;
					DataProcess.c := 0;
					DataProcess.e := 0;
				}
				transition dp1_DATA_EXPIR --> dp3 { |;|
					{ |;|
						guard (DataProcess.e == Node.DATA_EXPIR);
						Node.localPC := (Node.localPC && (DataProcess.e == Node.DATA_EXPIR));
					}
					if (DataProcess.mySeq == 1)
					{
						output Node.Log(TERMIN_DM1, Node.localTime);
					}
					else
					{
						if (DataProcess.mySeq == 2)
						{
							output Node.Log(TERMIN_DM2, Node.localTime);
						}
					}
				}
				transition dp1_reach_k --> dp2 { |;|
					{ |;|
						guard (DataProcess.cl == DataProcess.t);
						Node.localPC := (Node.localPC && (DataProcess.cl == DataProcess.t));
					}
					{ |;|
						guard (((DataProcess.c >= DataProcess.k) || (&spec::Trickle.Node.my_buff[(DataProcess.mySeq + (- Node.MIN_SEQ))].fragment == UNDEF_FRAGMENT)) && (DataProcess.e < Node.DATA_EXPIR));
						Node.localPC := (Node.localPC && (((DataProcess.c >= DataProcess.k) || (&spec::Trickle.Node.my_buff[(DataProcess.mySeq + (- Node.MIN_SEQ))].fragment == UNDEF_FRAGMENT)) && (DataProcess.e < Node.DATA_EXPIR)));
					}
				}
			}

			state dp2 {
				transition dp_resetTau --> dp1 { |;|
					{ |;|
						guard ((DataProcess.cl > DataProcess.t) && (DataProcess.cl == DataProcess.tau));
						Node.localPC := (Node.localPC && ((DataProcess.cl > DataProcess.t) && (DataProcess.cl == DataProcess.tau)));
					}
					{ |;|
						guard (DataProcess.e < Node.DATA_EXPIR);
						Node.localPC := (Node.localPC && (DataProcess.e < Node.DATA_EXPIR));
					}
					if ((2 * DataProcess.tau) <= DataProcess.tau_h)
					{
						DataProcess.tau := (2 * DataProcess.tau);
					}
					else
					{
						if ((2 * DataProcess.tau) > DataProcess.tau_h)
						{
							DataProcess.tau := DataProcess.tau_h;
						}
					}
					invoke#method DataProcess.t newfresh;
					{ |;|
						guard (((DataProcess.tau / 2) <= DataProcess.t) && (DataProcess.t < DataProcess.tau));
						Node.localPC := (Node.localPC && (((DataProcess.tau / 2) <= DataProcess.t) && (DataProcess.t < DataProcess.tau)));
					}
					DataProcess.e := (+ 1);
					DataProcess.cl := 0;
					DataProcess.c := 0;
				}
				transition dp2_receiveDM_consistent --> dp2 { |;|
					{ |;|
						guard (DataProcess.cl < DataProcess.tau);
						Node.localPC := (Node.localPC && (DataProcess.cl < DataProcess.tau));
					}
					{ |;|
						{ |;|
							guard (DataProcess.e < Node.DATA_EXPIR);
							Node.localPC := (Node.localPC && (DataProcess.e < Node.DATA_EXPIR));
						}
						if (DataProcess.mySeq == 1)
						{
							input Node.DataMsg1(DataProcess.d, Node.timeEmit);
						}
						else
						{
							input Node.DataMsg2(DataProcess.d, Node.timeEmit);
						}
						{ |;|
							guard (Node.timeEmit <= Node.localTime);
							Node.localPC := (Node.localPC && (Node.timeEmit <= Node.localTime));
						}
						DataProcess.consistent := true;
						if (DataProcess.mySeq == &spec::Trickle.Node.DataProcess.d.seq)
						{ |;|
							&spec::Trickle.Node.my_buff[(&spec::Trickle.Node.DataProcess.d.seq + (- Node.MIN_SEQ))] := DataProcess.d;
							&spec::Trickle.Node.myseq_buff[(&spec::Trickle.Node.DataProcess.d.seq + (- Node.MIN_SEQ))] := 1;
							&spec::Trickle.Node.firmware[&spec::Trickle.Node.DataProcess.d.offset] := &spec::Trickle.Node.DataProcess.d.fragment;
						}
						else
						{
							DataProcess.consistent := false;
						}
					}
					guard DataProcess.consistent;
					DataProcess.c := (+ 1);
				}
				transition dp2_receiveDM_inconsistent --> dp1 { |;|
					{ |;|
						guard (DataProcess.cl < DataProcess.tau);
						Node.localPC := (Node.localPC && (DataProcess.cl < DataProcess.tau));
					}
					{ |;|
						{ |;|
							guard (DataProcess.e < Node.DATA_EXPIR);
							Node.localPC := (Node.localPC && (DataProcess.e < Node.DATA_EXPIR));
						}
						if (DataProcess.mySeq == 1)
						{
							input Node.DataMsg1(DataProcess.d, Node.timeEmit);
						}
						else
						{
							input Node.DataMsg2(DataProcess.d, Node.timeEmit);
						}
						{ |;|
							guard (Node.timeEmit <= Node.localTime);
							Node.localPC := (Node.localPC && (Node.timeEmit <= Node.localTime));
						}
						DataProcess.consistent := true;
						if (DataProcess.mySeq == &spec::Trickle.Node.DataProcess.d.seq)
						{ |;|
							&spec::Trickle.Node.my_buff[(&spec::Trickle.Node.DataProcess.d.seq + (- Node.MIN_SEQ))] := DataProcess.d;
							&spec::Trickle.Node.myseq_buff[(&spec::Trickle.Node.DataProcess.d.seq + (- Node.MIN_SEQ))] := 1;
							&spec::Trickle.Node.firmware[&spec::Trickle.Node.DataProcess.d.offset] := &spec::Trickle.Node.DataProcess.d.fragment;
						}
						else
						{
							DataProcess.consistent := false;
						}
					}
					guard (! DataProcess.consistent);
					DataProcess.tau := DataProcess.tau_l;
					invoke#method DataProcess.t newfresh;
					{ |;|
						guard (((DataProcess.tau / 2) <= DataProcess.t) && (DataProcess.t < DataProcess.tau));
						Node.localPC := (Node.localPC && (((DataProcess.tau / 2) <= DataProcess.t) && (DataProcess.t < DataProcess.tau)));
					}
					DataProcess.cl := 0;
					DataProcess.c := 0;
					DataProcess.e := 0;
				}
			}

			state< final > dp3 {
			}

		@moe:
		}

	@instance:
		#static#instance executable< model: DataProcess , instance: [ + ] > DataProcess1 {
		@moe:
			@create{
				mySeq := 1;
			}

		}
		#static#instance executable< model: DataProcess , instance: [ + ] > DataProcess2 {
		@moe:
			@create{
				mySeq := 2;
			}

		}

	@moe:
		@init{ |;|
			{ |ยง|
				Node.node_time := Node.$time#initial;
				Node.z := Node.$delta#initial;
			}
			invoke#method Node.z newfresh;
			Node.localTime := (Node.localTime + Node.z);
			{ |;|
				guard (Node.z > 0);
				Node.localPC := (Node.localPC && (Node.z > 0));
			}
		}
		@irun{ |;|
			guard (Node.z > 0);
			Node.localPC := (Node.localPC && (Node.z > 0));
		}
		@run{ |;|
			{ |ยง|
				newfresh(Node.z)
				Node.node_time := (Node.node_time + Node.z);
				Node.localTime := (Node.localTime + Node.z);
				if ${ status#is enable spec::Trickle.Node.ControlProcess }
				{
					ControlProcess.cl := (ControlProcess.cl + Node.z);
				}
				if ${ status#is enable spec::Trickle.Node.DataProcess1 }
				{
					spec::Trickle.Node.DataProcess1.cl := (spec::Trickle.Node.DataProcess1.cl + Node.z);
				}
				if ${ status#is enable spec::Trickle.Node.DataProcess2 }
				{
					spec::Trickle.Node.DataProcess2.cl := (spec::Trickle.Node.DataProcess2.cl + Node.z);
				}
			}
			schedule;
			Node.undef_DM1 := (&spec::Trickle.Node.my_buff[0].fragment == UNDEF_FRAGMENT);
			Node.undef_DM2 := (&spec::Trickle.Node.my_buff[1].fragment == UNDEF_FRAGMENT);
		}
		@schedule{ |i|
			run Node.ControlProcess;
			run Node.DataProcess1;
			run Node.DataProcess2;
		}
	}

	lifeline statemachine< or > Observer {
	@property:
		var integer uncoveredExit = 0;
		var INFO_KIND mess;
		var integer[ 2 ] seqBuff;
		var DATA_MESSAGE dataMessage;

	@region:
		state< initial > startup {
			transition o_startup --> o#0;
		}

		state o#0 {
			transition n1_out_Log --> o#1 {
				@observe( ctx: spec::Trickle ) {
					output spec::Trickle.n1.Log(Observer.mess);
				} [ (Observer.mess == INIT) ];
			}
			transition< else > n1_out_Log_failed --> FAILED { |;|
				guard (Observer.uncoveredExit > 1);
				exit "Unfound Trace point< output n1->Log >";
			}
			@enable{
				Observer.uncoveredExit := 0;
			}
		}

		state o#1 {
			transition n2_out_Log --> o#2 {
				@observe( ctx: spec::Trickle ) {
					output spec::Trickle.n2.Log(Observer.mess);
				} [ (Observer.mess == INIT) ];
			}
			transition< else > n2_out_Log_failed --> FAILED { |;|
				guard (Observer.uncoveredExit > 1);
				exit "Unfound Trace point< output n2->Log >";
			}
			@enable{
				Observer.uncoveredExit := 0;
			}
		}

		state o#2 {
			transition n3_out_Log --> o#3 {
				@observe( ctx: spec::Trickle ) {
					output spec::Trickle.n3.Log(Observer.mess);
				} [ (Observer.mess == INIT) ];
			}
			transition< else > n3_out_Log_failed --> FAILED { |;|
				guard (Observer.uncoveredExit > 1);
				exit "Unfound Trace point< output n3->Log >";
			}
			@enable{
				Observer.uncoveredExit := 0;
			}
		}

		state o#3 {
			transition n1_out_CM --> o#4 {
				@observe( ctx: spec::Trickle ) {
					output spec::Trickle.n1.ControlMsg(Observer.seqBuff);
				} [ ((&spec::Trickle.Observer.seqBuff[0] == 1) && (&spec::Trickle.Observer.seqBuff[1] == 1)) ];
			}
			transition< else > n1_out_CM_failed --> FAILED { |;|
				guard (Observer.uncoveredExit > 1);
				exit "Unfound Trace point< output n4->ControlMsg >";
			}
			@enable{
				Observer.uncoveredExit := 0;
			}
		}

		state o#4 {
			transition n2_in_CM --> o#5 {
				@observe( ctx: spec::Trickle ) {
					input spec::Trickle.n2.ControlMsg(Observer.seqBuff);
				} [ ((&spec::Trickle.Observer.seqBuff[0] == 1) && (&spec::Trickle.Observer.seqBuff[1] == 1)) ];
			}
			transition< else > n2_in_CM_failed --> FAILED { |;|
				guard (Observer.uncoveredExit > 1);
				exit "Unfound Trace point< input n2->ControlMsg >";
			}
			@enable{
				Observer.uncoveredExit := 0;
			}
		}

		state o#5 {
			transition n3_in_CM --> o#6 {
				@observe( ctx: spec::Trickle ) {
					input spec::Trickle.n3.ControlMsg(Observer.seqBuff);
				} [ ((&spec::Trickle.Observer.seqBuff[0] == 1) && (&spec::Trickle.Observer.seqBuff[1] == 1)) ];
			}
			transition< else > n3_in_CM_failed --> FAILED { |;|
				guard (Observer.uncoveredExit > 1);
				exit "Unfound Trace point< output n3->ControlMsg >";
			}
			@enable{
				Observer.uncoveredExit := 0;
			}
		}

		state o#6 {
			transition n1_out_DM1 --> o#7 {
				@observe( ctx: spec::Trickle ) {
					output spec::Trickle.n1.DataMsg1(Observer.dataMessage);
				} [ (&spec::Trickle.Observer.dataMessage.seq == 1) ];
			}
			transition< else > n1_out_DM1_failed --> FAILED { |;|
				guard (Observer.uncoveredExit > 3);
				exit "Unfound Trace point< output n1->DataMsg1 >";
			}
			@enable{
				Observer.uncoveredExit := 0;
			}
		}

		state o#7 {
			transition n2_in_DM1 --> o#8 {
				@observe( ctx: spec::Trickle ) {
					input spec::Trickle.n2.DataMsg1(Observer.dataMessage);
				} [ (&spec::Trickle.Observer.dataMessage.seq == 1) ];
			}
			transition< else > n2_in_DM1_failed --> FAILED { |;|
				guard (Observer.uncoveredExit > 3);
				exit "Unfound Trace point< input n2->DataMsg1 >";
			}
			@enable{
				Observer.uncoveredExit := 0;
			}
		}

		state o#8 {
			transition n4_out_Log --> o#9 {
				@observe( ctx: spec::Trickle ) {
					output spec::Trickle.n3.Log(Observer.mess);
				} [ (Observer.mess == TERMIN_CM) ];
			}
			transition< else > n3_out_Log_failed --> FAILED { |;|
				guard (Observer.uncoveredExit > 5);
				exit "Unfound Trace point< output n3->Log >";
			}
			@enable{
				Observer.uncoveredExit := 0;
			}
		}

		state o#9 {
			transition n4_out_Log --> o#10 {
				@observe( ctx: spec::Trickle ) {
					output spec::Trickle.n3.Log(Observer.mess);
				} [ (Observer.mess == TERMIN_DM1) ];
			}
			transition< else > n3_out_Log_failed --> FAILED { |;|
				guard (Observer.uncoveredExit > 5);
				exit "Unfound Trace point< output n3->Log >";
			}
			@enable{
				Observer.uncoveredExit := 0;
			}
		}

		state o#10 {
			transition n4_out_Log --> PASS {
				@observe( ctx: spec::Trickle ) {
					output spec::Trickle.n3.Log(Observer.mess);
				} [ (Observer.mess == TERMIN_DM2) ];
			}
			transition< else > n3_out_Log_failed --> FAILED { |;|
				guard (Observer.uncoveredExit > 5);
				exit "Unfound Trace point< output n3->Log >";
			}
			@enable{
				Observer.uncoveredExit := 0;
			}
		}

		state< final > PASS {
			@final{
				exit;
			}

		}

		state< final > FAILED {
		}

	@moe:
		@irun{
			Observer.uncoveredExit := (Observer.uncoveredExit + 1);
		}
	}

@instance:
	#static#instance executable< model: Node , instance: [ + ] > n1 {
	@moe:
		@create{ |;|
			my_buff := [ [ 1 , FRAGMENT_0 , 0 ] , [ 2 , FRAGMENT_1 , 1 ] ];
			firmware := [ FRAGMENT_0 , FRAGMENT_1 ];
			myseq_buff := 1;
			mydp_run := true;
		}

	}
	#static#instance executable< model: Node , instance: [ + ] > n2 {
	@moe:
		@create{ |;|
			my_buff := [ [ 0 , UNDEF_FRAGMENT , 0 ] , [ 0 , UNDEF_FRAGMENT , 1 ] ];
			firmware := [ UNDEF_FRAGMENT , UNDEF_FRAGMENT ];
			myseq_buff := 0;
			mydp_run := false;
		}

	}
	#static#instance executable< model: Node , instance: [ + ] > n3 {
	@moe:
		@create{ |;|
			my_buff := [ [ 0 , UNDEF_FRAGMENT , 0 ] , [ 0 , UNDEF_FRAGMENT , 1 ] ];
			firmware := [ UNDEF_FRAGMENT , UNDEF_FRAGMENT ];
			myseq_buff := 0;
			mydp_run := false;
		}

	}

@com:
	connector< env > _#connector_0 {
		output n1->Log;
		output n2->Log;
		output n3->Log;
	}
	connector< multicast > _#connector_1 {
		output n1->ControlMsg;
		input< buffer: n2.bufferNode > n2->ControlMsg;
		input< buffer: n3.bufferNode > n3->ControlMsg;
	}
	connector< multicast > _#connector_2 {
		output n1->DataMsg1;
		input< buffer: n2.bufferNode > n2->DataMsg1;
		input< buffer: n3.bufferNode > n3->DataMsg1;
	}
	connector< multicast > _#connector_3 {
		output n1->DataMsg2;
		input< buffer: n2.bufferNode > n2->DataMsg2;
		input< buffer: n3.bufferNode > n3->DataMsg2;
	}
	connector< multicast > _#connector_4 {
		output n2->ControlMsg;
		input< buffer: n3.bufferNode > n3->ControlMsg;
	}
	connector< multicast > _#connector_5 {
		output n2->DataMsg1;
		input< buffer: n3.bufferNode > n3->DataMsg1;
	}
	connector< multicast > _#connector_6 {
		output n2->DataMsg2;
		input< buffer: n3.bufferNode > n3->DataMsg2;
	}
	connector< multicast > _#connector_7 {
		output n3->ControlMsg;
		input< buffer: n1.bufferNode > n1->ControlMsg;
		input< buffer: n2.bufferNode > n2->ControlMsg;
	}
	connector< multicast > _#connector_8 {
		output n3->DataMsg1;
		input< buffer: n1.bufferNode > n1->DataMsg1;
		input< buffer: n2.bufferNode > n2->DataMsg1;
	}
	connector< multicast > _#connector_9 {
		output n3->DataMsg2;
		input< buffer: n1.bufferNode > n1->DataMsg2;
		input< buffer: n2.bufferNode > n2->DataMsg2;
	}

@moe:
	@schedule{ |;|
		{ |i|
			run spec::Trickle.Node;
		}
		run spec::Trickle.Observer;
	}
}
